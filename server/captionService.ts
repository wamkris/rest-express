import { fetchTranscript, YoutubeTranscriptDisabledError, YoutubeTranscriptNotAvailableError } from 'youtube-transcript-plus';
import { storage } from './storage';
import { InsertTranscriptBlock } from '@shared/schema';

interface TranscriptSegment {
  text: string;
  duration: number;
  offset: number;
  lang?: string;
}

interface TranscriptResult {
  blocks: InsertTranscriptBlock[];
  tqs: number;
  language: string;
  source: string;
}

export class CaptionService {
  private readonly TQS_WEIGHTS = {
    completeness: 0.3,
    accuracy: 0.25,
    granularity: 0.25,
    readability: 0.2
  };

  async fetchAndStoreTranscript(videoId: string): Promise<TranscriptResult | null> {
    try {
      const transcript = await this.fetchTranscript(videoId);
      if (!transcript) {
        return null;
      }

      const { blocks, language, source } = this.convertToBlocks(videoId, transcript);
      const tqs = this.calculateTQS(blocks, transcript);

      await storage.createTranscriptBlocks(blocks);

      return { blocks, tqs, language, source };
    } catch (error) {
      console.error(`Failed to fetch transcript for ${videoId}:`, error);
      return null;
    }
  }

  private async fetchTranscript(videoId: string, preferredLang: string = 'en'): Promise<TranscriptSegment[] | null> {
    try {
      const transcript = await fetchTranscript(videoId, {
        lang: preferredLang
      });
      return transcript;
    } catch (error) {
      if (error instanceof YoutubeTranscriptDisabledError) {
        console.warn(`Transcripts disabled for video: ${videoId}`);
        return null;
      }
      if (error instanceof YoutubeTranscriptNotAvailableError) {
        console.warn(`Transcript not available for video: ${videoId}`);
        return null;
      }
      throw error;
    }
  }

  private convertToBlocks(videoId: string, segments: TranscriptSegment[]): {
    blocks: InsertTranscriptBlock[];
    language: string;
    source: string;
  } {
    const blocks: InsertTranscriptBlock[] = segments.map((segment, index) => ({
      videoId,
      blockIndex: index,
      startTime: Math.floor(segment.offset),
      endTime: Math.floor(segment.offset + segment.duration),
      text: segment.text.trim(),
      language: segment.lang || 'en',
      source: 'youtube',
      tqs: 0,
      createdAt: new Date()
    }));

    const language = segments[0]?.lang || 'en';
    return { blocks, language, source: 'youtube' };
  }

  calculateTQS(blocks: InsertTranscriptBlock[], rawSegments: TranscriptSegment[]): number {
    const completeness = this.scoreCompleteness(blocks);
    const accuracy = this.scoreAccuracy(rawSegments);
    const granularity = this.scoreGranularity(blocks);
    const readability = this.scoreReadability(blocks);

    const tqs = Math.round(
      completeness * this.TQS_WEIGHTS.completeness +
      accuracy * this.TQS_WEIGHTS.accuracy +
      granularity * this.TQS_WEIGHTS.granularity +
      readability * this.TQS_WEIGHTS.readability
    );

    return Math.max(0, Math.min(100, tqs));
  }

  private scoreCompleteness(blocks: InsertTranscriptBlock[]): number {
    if (blocks.length === 0) return 0;

    let totalCoverage = 0;
    for (let i = 0; i < blocks.length - 1; i++) {
      const gap = blocks[i + 1].startTime - blocks[i].endTime;
      if (gap <= 1) totalCoverage += blocks[i].endTime - blocks[i].startTime;
    }

    const lastBlock = blocks[blocks.length - 1];
    totalCoverage += lastBlock.endTime - lastBlock.startTime;

    const totalDuration = blocks[blocks.length - 1].endTime - blocks[0].startTime;
    const coverageRatio = totalDuration > 0 ? totalCoverage / totalDuration : 0;

    return Math.min(100, coverageRatio * 100);
  }

  private scoreAccuracy(segments: TranscriptSegment[]): number {
    if (segments.length === 0) return 0;

    let accuracyScore = 100;

    const hasAutoGenerated = segments.some(s => 
      s.text.includes('[Music]') || 
      s.text.includes('[Applause]') ||
      s.text.includes('[Laughter]')
    );
    if (hasAutoGenerated) accuracyScore -= 10;

    const avgTextLength = segments.reduce((sum, s) => sum + s.text.length, 0) / segments.length;
    if (avgTextLength < 20) accuracyScore -= 15;
    if (avgTextLength > 200) accuracyScore -= 10;

    const hasProperPunctuation = segments.filter(s => /[.!?]/.test(s.text)).length / segments.length;
    if (hasProperPunctuation < 0.3) accuracyScore -= 20;

    return Math.max(0, Math.min(100, accuracyScore));
  }

  private scoreGranularity(blocks: InsertTranscriptBlock[]): number {
    if (blocks.length === 0) return 0;

    const avgBlockDuration = blocks.reduce((sum, b) => sum + (b.endTime - b.startTime), 0) / blocks.length;

    if (avgBlockDuration < 2) return 100;
    if (avgBlockDuration < 4) return 90;
    if (avgBlockDuration < 6) return 75;
    if (avgBlockDuration < 10) return 60;
    if (avgBlockDuration < 15) return 40;
    return 20;
  }

  private scoreReadability(blocks: InsertTranscriptBlock[]): number {
    if (blocks.length === 0) return 0;

    let readabilityScore = 0;
    let validBlocks = 0;

    for (const block of blocks) {
      const words = block.text.split(/\s+/).filter(w => w.length > 0);
      if (words.length === 0) continue;

      validBlocks++;
      let blockScore = 100;

      const avgWordLength = words.reduce((sum, w) => sum + w.length, 0) / words.length;
      if (avgWordLength < 3 || avgWordLength > 12) blockScore -= 15;

      const hasCapitalization = /[A-Z]/.test(block.text);
      if (!hasCapitalization) blockScore -= 10;

      const specialCharRatio = (block.text.match(/[^a-zA-Z0-9\s.,!?'"]/g) || []).length / block.text.length;
      if (specialCharRatio > 0.1) blockScore -= 20;

      readabilityScore += Math.max(0, blockScore);
    }

    return validBlocks > 0 ? readabilityScore / validBlocks : 0;
  }

  async getTranscriptContext(videoId: string, timestamp: number): Promise<{
    current: InsertTranscriptBlock | null;
    previous: InsertTranscriptBlock[];
    next: InsertTranscriptBlock[];
  }> {
    const allBlocks = await storage.getTranscriptBlocksByVideoId(videoId);
    
    const currentIndex = allBlocks.findIndex(
      block => timestamp >= block.startTime && timestamp <= block.endTime
    );

    if (currentIndex === -1) {
      return { current: null, previous: [], next: [] };
    }

    return {
      current: allBlocks[currentIndex],
      previous: allBlocks.slice(Math.max(0, currentIndex - 3), currentIndex),
      next: allBlocks.slice(currentIndex + 1, Math.min(allBlocks.length, currentIndex + 4))
    };
  }
}

export const captionService = new CaptionService();
